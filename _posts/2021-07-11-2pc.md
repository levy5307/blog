---
layout: post
title: 2pc
date: 2021-07-11
Author: levy5307
tags: [分布式事务]
comments: true
toc: true
---

在分布式事务中，不能简单的向所有节点发送提交请求，然后各个节点去独立的执行事务提交。例如：

- 某些节点检测到违反约束或者冲突因而决定终止，而其他节点则可能成功提交

- 发送给某些节点的提交请求可能因为网络原因丢失，而发往其他节点的请求则顺利通过

- 某些节点可能在日志记录写入之前发生崩溃，然后再恢复时回滚，而其他节点成功提交

因为部分节点提交成功、而其他一些节点提交失败的情况，将会破坏原子性。

之前的[文章](https://levy5307.github.io/blog/distributed-transaction/)讲到过，分布式事务的原子性是由2pc来保证的。

## 2pc的基本流程

2pc全称two-phase commit，即两阶段提交，它将事务的提交分为两个阶段。

阶段1：协调者（即事务管理器）发送prepare request至所有的参与者。询问其是否可提交，并跟踪参与者的回应。

在这个阶段，当参与者回复ready之前，需检查是否存在违反约束或者冲突，并要确保任何情况都可以提交，这是***参与者所作出的承诺***。

阶段2：协调者获取到所有参与者的回答后，根据具体情况判断提交与否：

- 如果所有参与者回复ready，表示他们已经准备好提交，则协调者会发出commit request给参与者，进行实际的提交。

- 如果有至少一个参与者回复abort，表示该参与者无法正确提交，协调者就会向参与者发送放弃请求。

在这个阶段中，协调者根据所有参与者的回复获取事务提交与否的最终决定，并需要将最终决定落盘。这个时刻称为***提交点***。在落盘之后，需要向所有参与者发送提交请求，即使发生了超时等失败，也要一直重试直到成功。这是***协调者所作出的承诺***。

***这里协调者和参与者的两个承诺是不可撤销的，必须严格贯彻。也正是这两个承诺才保证了2pc的原子性***。

![事务T正常流程](../images/2pc-normal.png)

上图是事务T的正常流程，从图中可以看到，2pc需要协调者经过2次日志落盘，参与者2次日志落盘，以及2次rpc往返才能返回给客户端响应。

![事务T失败流程](../images/2pc-abnormal.png)

上图中展示的是参与者由于检测到违反冲突而导致事务失败。可以看出其流程与正常的事务流程一样，也是需要协调者2次落盘，参与者2次落盘，以及2次rpc往返才能给客户端响应。

## 阻塞式协议

从上面的基本流程可以看出来，2pc是一个阻塞式协议。当参与者回复prepare ready之后，需要阻塞一直等待协调者的最终决定。如果在决定到达之前协调者发生故障，则参与者只能等待协调者恢复。这里主要是由于获取不到协调者的最终决定，参与者不知道下一步该如何操作，因为有可能有其他参与者返回了abort而导致协调者最终放弃事务。

![](../images/2pc-coordinator-crash.png)

上图是2pc执行过程中协调者宕机的情况，此时参与者会一直等待协调者恢复。而由于协调者的事务执行过程都有日志落盘，所以当协调者恢复后，可以继续执行事务过程。

对于上述问题，在实践中多采用2pc和Paxos等共识协议结合的方式，由Paxos来保证协调者的高可用。

不过参与者发生故障却不会导致阻塞。例如：

- 如果prepare到来之前或者prepare ack发送之前参与者故障，那么协调者将取消事务。

- 如果参与者回复了parepare ack为ready，协调者决定提交事务时参与者发生故障，那么协调者将一直重试向参与者发送commit请求。

## 2pc的缺点

通过上文描述的2pc的基本过程，我们可以知道2pc有以下几个缺点：

- 单点问题。很显然协调者是一个单点，只要协调者宕机，系统则无法运转

- 阻塞式协议。具体参见上一节

- 效率低。用户感知到的提交延时是2次协调者写日志、2次参与者写日志以及2次rpc往返耗时

## 业内的优化实现

下面我们看看针对以下问题，业内实际产品是怎么解决的。

### Percolator

### OceanBase

## Reference

[Percolator](https://levy5307.github.io/blog/percolator/)


