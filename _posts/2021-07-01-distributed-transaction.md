---
layout: post
title: 分布式事务
date: 2021-07-01
Author: levy5307
tags: [分布式事务]
comments: true
---

## 事务的属性

ACID，事务的4个属性，这个每个人都很熟悉。其中：

***A***代表原子性，即：事务中的操作要么全部正确执行，要么全部不执行。在分布式系统中，其主要由2pc协议来保证的（另外还有一个3pc协议，但是只停留在理论阶段，没有太多实践意义），后面我会专门写一篇文章来介绍2pc的原理以及各个产品的优化实践。

***I***代表隔离性，即：多个事务并发执行时，对每个事务来说，它并不会感知系统中有其他事务在同时执行。隔离性有很多个级别，针对不同的级别有多种不同的实现方法，如：MVCC、2PL等。

***D***代表持久性，即：一个事务在提交之后，该事务对数据库的改变是持久的。持久性主要通过redo log来保证的，即如果宕机导致内存中的数据丢失了，需要通过redo log回放来进行恢复。关于持久性，需要注意一点的是，并不存在完美的、绝对的持久性，因为磁盘可能会坏掉，即使有多个副本，理论上也存在多个副本所在的磁盘同时坏掉的情况。多副本这些手段只是用来降低风险，并不能使之达到绝对的持久性。

***C***代表一致性。即：数据库必须保证事务的执行从一个一致性状态转移到另一个一致性状态。简单说就是数据库从一个正确的状态到另一个正确的状态。比如转账事务完成后，转账双方的总金额不能多也不能少。另外这里的一致性和多副本的一致性也不是一个概念。多副本一致性是指：

- 查询和更新单个对象的操作按一定顺序执行

- 更新操作的效果必然反映在后续查询操作返回的结果中

在ACID中，C是目的，AID是手段，为了达到C的目的而提供的手段。AID是数据库自身的属性，C则更多的是应用层的属性，应用层利用数据库的AID的这三个特性来达到C。说到这里可能有些混乱，举个例子：

在银行系统中，A要向B转账100元，而A的账户余额只有50元，并且应用层给账户余额这一列添加了值不能小于0的约束，那么很显然这条事务会执行失败。因为50-100=-50，很显然不符合约束。此时事务会回滚，这样应用层便利用了事务的AID特性保证了一致性C。

反之，如果用户没有为账户余额这一列添加不能小于0的约束，那么事务便会执行成功，导致A的账户余额变成了-50，显然这是不正确的状态。

由此可见，一致性的保证是由应用层来保证的。

另外说一句，对于一个涉及a、b节点的分布式事务，如果节点a提交了本地事务，而节点b还没来得及提交，从而其他事务看到了其中间状态，这个问题是由隔离性来解决的。很多人误以为是一致性，其实是不对的。

## 弱隔离级别

严格意义上的隔离性是指假装没有发生并发，这意味着事务的最终执行结果与串行执行相同，然而这会严重影响性能。许多数据库不愿意牺牲性能，因而更多倾向于采用较弱的隔离级别。

弱隔离级别分为以下四种隔离级别：读未提交、读已提交、可重复读、串行化。

### 读未提交（read-uncommitted）

读未提交是指允许一个事务去读取其他事务尚未提交的数据，即***脏读***。用白话说就是你读取了别人正在处理的数据。

当存在以下问题时，需要解决脏读的问题：

- 如果事务会更新多个对象，那么脏读意味着其他事务会看到部分更新这种中间状态，而非看到全部。例如当收到一封电子邮件时，需要更新收件箱以及未读邮件数。如果用户只看到了新邮件但看不到更新的邮件数，则会带来一些困扰。如下图所示：

![](../images/distribute-transtion-1.png)

- 如果事务中止，则所有写入操作都需要回滚。如果发生了脏读，那么可能看到了一些稍后会回滚的数据。

同时，读未提交还有***脏写***的问题，即：写数据库时，会覆盖未成功提交的数据。

我们举一个汽车购买的例子来说明脏写的问题。购买汽车需要两次数据库写入：网站上商品买主需要更新为新卖家；销售发票也要随之更新。在下图中，用户1和用户2试图购买同一辆车，当脏写发生时，会导致商品卖给了用户1，发票却给了用户2。

![](../images/distribute-transtion-2.png)

### 读已提交（read-committed）

为了解决脏读/脏写的问题，引入了读已提交。其只提供如下两个保证：

- 读数据时，只能看到已经成功提交的数据（防止脏读）

- 写数据时，只会覆盖已经成功提交的数据（防止脏写）

数据库通常使用行锁来解决脏写的问题，即当事务想要修改某个对象时，首先获取对象的锁，然后一直持有锁直到事务提交或中止。给定时刻只有一个事务可以拿到特定对象的锁，如果另一个事务尝试更新同一个对象，其必须等待，直到持有锁的事务提交或中止后，获取锁并继续。

对于脏读却不能像解决脏写问题一样简单地使用读锁，因为这样只读事务会被长时间的写事务阻塞，严重影响只读事务的延迟。所以大多数数据库都是采用了多版本的方式来解决脏读问题：对于每个待更新的对象，数据库都维护其旧值和即将更新的新值，在写事务提交之前，所有读都获取旧值；而当写事务提交之后，则读取新值。具体如下图所示：

![](../images/distribute-transtion-3.png)

虽然解决了脏读和脏写的问题，但是还有不可重复读的问题存在。我们可以通过银行转账的例子来看一下什么是不可重复读

![](../images/distribute-transtion-4.png)

### 可重复读

***幻读:*** 白话说就是你读数据的时候别人插进来对数据操作了。

### 串行化

串行化达到的效果就是，你读的时候别人看不到，完全隔离开，好像在串行化执行。

## 未完待续

