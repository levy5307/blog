---
layout: post
title: 分布式事务
date: 2021-07-01
Author: levy5307
tags: [分布式事务]
comments: true
---

## 事务的属性

ACID，事务的4个属性，这个每个人都很熟悉。其中：

***A***代表原子性，即：事务中的操作要么全部正确执行，要么全部不执行。在分布式系统中，其主要由2pc协议来保证的（另外还有一个3pc协议，但是只停留在理论阶段，没有太多实践意义），后面我会专门写一篇文章来介绍2pc的原理以及各个产品的优化实践。

***I***代表隔离性，即：多个事务并发执行时，对每个事务来说，它并不会感知系统中有其他事务在同时执行。隔离性有很多个级别，针对不同的级别有多种不同的实现方法，如：MVCC、2PL等。

***D***代表持久性，即：一个事务在提交之后，该事务对数据库的改变是持久的。持久性主要通过redo log来保证的，即如果宕机导致内存中的数据丢失了，需要通过redo log回放来进行恢复。关于持久性，需要注意一点的是，并不存在完美的、绝对的持久性，因为磁盘可能会坏掉，即使有多个副本，理论上也存在多个副本所在的磁盘同时坏掉的情况。多副本这些手段只是用来降低风险，并不能使之达到绝对的持久性。

***C***代表一致性。即：数据库必须保证事务的执行从一个一致性状态转移到另一个一致性状态。简单说就是数据库从一个正确的状态到另一个正确的状态。比如转账事务完成后，转账双方的总金额不能多也不能少。另外这里的一致性和多副本的一致性也不是一个概念。多副本一致性是指：

- 查询和更新单个对象的操作按一定顺序执行

- 更新操作的效果必然反映在后续查询操作返回的结果中

在ACID中，C是目的，AID是手段，为了达到C的目的而提供的手段。AID是数据库自身的属性，C则更多的是应用层的属性，应用层利用数据库的AID的这三个特性来达到C。说到这里可能有些混乱，举个例子：

在银行系统中，A要向B转账100元，而A的账户余额只有50元，并且应用层给账户余额这一列添加了值不能小于0的约束，那么很显然这条事务会执行失败。因为50-100=-50，很显然不符合约束。此时事务会回滚，这样应用层便利用了事务的AID特性保证了一致性C。

反之，如果用户没有为账户余额这一列添加不能小于0的约束，那么事务便会执行成功，导致A的账户余额变成了-50，显然这是不正确的状态。

由此可见，一致性的保证是由应用层来保证的。

另外说一句，对于一个涉及a、b节点的分布式事务，如果节点a提交了本地事务，而节点b还没来得及提交，从而其他事务看到了其中间状态，这个问题是由隔离性来解决的。很多人误以为是一致性，其实是不对的。

## 弱隔离级别

讲完了事务的基本属性，这篇文章主要讲一下事务的几个弱隔离级别及其实现。

## 未完待续

