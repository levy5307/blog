---
layout: post
title: WiscKey
date: 2021-09-08
Author: levy5307
tags: [论文]
comments: true
toc: true
---

## Background

目前最优秀的存储系统，很多有依赖于LSM-tree来构建。LSM-tree通过提高IO放大换取顺序写，以提升写入性能，这对于HDD磁盘这种random IO比sequential IO慢100倍的情况具有很大的优化效果。然而对于SSD却不一定有这么明显的效果，主要原因有三：

- SSD的random IO和sequential IO性能相差不想HDD那么大。因此像LSM-tree这样通过大量顺序写来减少随机写的实现方式，可能会浪费磁盘带宽

- SSD内部实现由很大的并行性，基于SSD的LSM-tree将会伤害这种并行性

- LSM-tree由于比较大的写放大，会显著减少SSD磁盘寿命

基于上述几个因素，在SSD至上运行LSM-tree将会影响SSD性能，减少90%的吞吐并增加10倍的写入负载。尽管在SSD上运行LSM-tree比在HDD上会更快一些，但是SSD的潜能并没有被完全开发出来。

## WiscKey

为了充分利用SSD的潜能，WiscKey有如下4个重要的ideas:

1. 即将key和value分开，value存储在vLog中，key及对应的value地址存储在LSM-tree

2. 为了处理范围查询过程中导致的value非顺序读，WiscKey充分利用了SSD多线程并行随机读性能高的特点，具体如下图，32线程随机读性能在请求64KB大小时，已和顺序读相差无几。

![](../images/wisckey-ssd-throughput.jpg)

3. WiscKey实现了crash-consistency和garbage-collection技术以高效管理vLog

4. WiscKey移除了LSM-tree的WAL，提升了写入性能，并且不会影响一致性。

### Design Goals

- Low write amplification. 写放大会引入不必要的写，会消耗很多磁盘带宽（高达90%），并且会降低SSD的使用寿命。

- Low read amplification. 读放大会有两个危害：1. 查询的吞吐会严重下降；2. 过多的数据加载到内存中，降低了cache的效率。

- SSD optimized. WiscKey根据SSD的特性进行了优化。

- Feature-rich API.

- Realistic key-value size. 对KV存储来说，key一般偏小，而value则会变化比较大（从100B到4KB），WiscKey设计以对这种现实场景提供高性能。

### Key-Value Separation

WiscKey的思想很简单：将key和value分开存储，value单独存放在其他位置，key和value的地址存储在LSM-tree上。如下图所示：

![](../images/wisckey-data-layout.jpg)

因为key通常比value小很多，这样可以大幅降低写放大。

***写入：*** 当插入一个数据时，value先被append到vLog中，然后key和value的地址被插入到LSM-tree中。当删除一个数据时，只需要在LSM-tree上删除数据，不用管vLog。当一个value在LSM-tree上可以找到对应的key时，该value就是有效的，其他无效的数据会在后续的gc过程中被清除掉。

***读取：*** 当读取时，先在LSM-tree上查找该key，如果找到了，再根据value地址去vLog中获取value。由于读取时需要额外多一次获取value的操作，很多人可能认为WiscKey会比LevelDB慢。然而，由于WiscKey的LSM-tree明显小于LevelDB，那么查找所需要查找的层数也会更小，并且会有更多的LSM-tree部分被缓存，缓存命中率也会增高。

### Challenges 

由于key-value分离，导致范围查询时有过多的随机IO，并且带来garbage collection和crash consistency挑战

### Parallel Range Query




